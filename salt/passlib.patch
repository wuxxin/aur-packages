--- a/salt/utils/pycrypto.py	2025-11-03 16:17:32.008120056 +0000
+++ b/salt/utils/pycrypto.py	2025-11-03 16:17:32.008120056 +0000
@@ -6,6 +6,7 @@
 import random
 import re
 import string
+import types

 import salt.utils.platform
 import salt.utils.stringutils
@@ -23,12 +24,19 @@
 except ImportError:
     HAS_RANDOM = False

+HAS_CRYPT = False
+
 try:
-    import crypt
+    import bcrypt
+
+    # Check if the patch for passlib is needed: __version__ exists but __about__ does not
+    if hasattr(bcrypt, "__version__") and not hasattr(bcrypt, "__about__"):
+        # Create a simple namespace object to mimic the old __about__ attribute
+        bcrypt.__about__ = types.SimpleNamespace(__version__=bcrypt.__version__)
+except ImportError:
+    # If bcrypt isn't installed, passlib will handle it gracefully. No patch needed
+    pass

-    HAS_CRYPT = True
-except (ImportError, PermissionError):
-    HAS_CRYPT = False

 try:
     import passlib.context
@@ -101,10 +109,7 @@
         raise CommandExecutionError(str(exc))


-if HAS_CRYPT:
-    methods = {m.name.lower(): m for m in crypt.methods}
-else:
-    methods = {}
+methods = {}
 known_methods = ["sha512", "sha256", "blowfish", "md5", "crypt"]


@@ -130,26 +135,6 @@
     return ctx.hash(**kwargs)


-def _gen_hash_crypt(crypt_salt=None, password=None, algorithm=None):
-    """
-    Generate /etc/shadow hash using the native crypt module
-    """
-    if crypt_salt is None:
-        # setting crypt_salt to the algorithm makes crypt generate
-        #  a salt compatible with the specified algorithm.
-        crypt_salt = methods[algorithm]
-    else:
-        if algorithm != "crypt":
-            # all non-crypt algorithms are specified as part of the salt
-            crypt_salt = f"${methods[algorithm].ident}${crypt_salt}"
-
-    try:
-        ret = crypt.crypt(password, crypt_salt)
-    except OSError:
-        ret = None
-    return ret
-
-
 def gen_hash(crypt_salt=None, password=None, algorithm=None):
     """
     Generate /etc/shadow hash
@@ -158,25 +143,24 @@
         password = secure_password()

     if algorithm is None:
-        # prefer the most secure natively supported method
-        algorithm = crypt.methods[0].name.lower() if HAS_CRYPT else known_methods[0]
+        # prefer sha512
+        algorithm = "sha512"

     if algorithm == "crypt" and crypt_salt and len(crypt_salt) != 2:
         log.warning("Hash salt is too long for 'crypt' hash.")

-    if HAS_CRYPT and algorithm in methods:
-        return _gen_hash_crypt(
-            crypt_salt=crypt_salt, password=password, algorithm=algorithm
-        )
-    elif HAS_PASSLIB and algorithm in known_methods:
+    if HAS_PASSLIB and algorithm in known_methods:
         return _gen_hash_passlib(
             crypt_salt=crypt_salt, password=password, algorithm=algorithm
         )
-    else:
+
+    if not HAS_PASSLIB:
         raise SaltInvocationError(
-            "Cannot hash using '{}' hash algorithm. Natively supported "
-            "algorithms are: {}. If passlib is installed ({}), the supported "
-            "algorithms are: {}.".format(
-                algorithm, list(methods), HAS_PASSLIB, known_methods
-            )
+            "This salt installation is configured to use passlib, but it is not installed."
+        )
+
+    raise SaltInvocationError(
+        "Cannot hash using '{}' hash algorithm. Supported algorithms are: {}".format(
+            algorithm, known_methods
         )
+    )
