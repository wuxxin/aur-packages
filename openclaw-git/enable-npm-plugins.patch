--- a/src/plugins/discovery.ts
+++ b/src/plugins/discovery.ts
@@ -301,6 +301,75 @@
   }
 }
 
+
+function discoverNpmPlugins(params: {
+  dir: string;
+  origin: PluginOrigin;
+  workspaceDir?: string;
+  candidates: PluginCandidate[];
+  diagnostics: PluginDiagnostic[];
+  seen: Set<string>;
+}) {
+  const nodeModules = path.join(params.dir, "node_modules");
+  if (!fs.existsSync(nodeModules)) {
+    return;
+  }
+
+  let entries: fs.Dirent[] = [];
+  try {
+    entries = fs.readdirSync(nodeModules, { withFileTypes: true });
+  } catch {
+    return;
+  }
+
+  for (const entry of entries) {
+    if (!entry.isDirectory()) continue;
+    
+    // Handle scoped packages
+    if (entry.name.startsWith("@")) {
+      const scopeDir = path.join(nodeModules, entry.name);
+      let scopeEntries: fs.Dirent[] = [];
+      try {
+        scopeEntries = fs.readdirSync(scopeDir, { withFileTypes: true });
+      } catch {
+        continue;
+      }
+      for (const scopeEntry of scopeEntries) {
+        if (!scopeEntry.isDirectory()) continue;
+        const fullPath = path.join(scopeDir, scopeEntry.name);
+        const manifest = readPackageManifest(fullPath);
+        if (!manifest || !getPackageManifestMetadata(manifest)) continue;
+        
+        // Use generic discovery but only because we confirmed manifest metadata exists
+        discoverInDirectory({
+          dir: fullPath,
+          origin: params.origin,
+          workspaceDir: params.workspaceDir,
+          candidates: params.candidates,
+          diagnostics: params.diagnostics,
+          seen: params.seen,
+        });
+      }
+      continue;
+    }
+
+    if (entry.name.startsWith(".")) continue;
+
+    const fullPath = path.join(nodeModules, entry.name);
+    const manifest = readPackageManifest(fullPath);
+    if (!manifest || !getPackageManifestMetadata(manifest)) continue;
+
+    discoverInDirectory({
+      dir: fullPath,
+      origin: params.origin,
+      workspaceDir: params.workspaceDir,
+      candidates: params.candidates,
+      diagnostics: params.diagnostics,
+      seen: params.seen,
+    });
+  }
+}
+
 export function discoverOpenClawPlugins(params: {
   workspaceDir?: string;
   extraPaths?: string[];
@@ -421,6 +490,15 @@
     seen,
   });
 
+  // Discover NPM package plugins in config dir (e.g. ~/.openclaw/node_modules)
+  discoverNpmPlugins({
+    dir: resolveConfigDir(),
+    origin: "global",
+    candidates,
+    diagnostics,
+    seen,
+  });
+
   const bundledDir = resolveBundledPluginsDir();
   if (bundledDir) {
     discoverInDirectory({

--- a/src/plugins/install.ts
+++ b/src/plugins/install.ts
@@ -340,6 +340,32 @@
   mode?: "install" | "update";
   dryRun?: boolean;
   expectedPluginId?: string;
 }): Promise<InstallPluginResult> {
+  // Force installation into user config directory if package.json exists there
+  const configPkgJson = path.join(CONFIG_DIR, "package.json");
+  if (await fileExists(configPkgJson)) {
+      const logger = params.logger ?? defaultLogger;
+      logger.info?.(`Installing ${params.spec} to ${CONFIG_DIR} using system package manager...`);
+
+      const hasPnpmLock = await fileExists(path.join(CONFIG_DIR, "pnpm-lock.yaml"));
+      const pm = hasPnpmLock ? "pnpm" : "npm";
+
+      const res = await runCommandWithTimeout([pm, "install", params.spec], {
+        cwd: CONFIG_DIR,
+        timeoutMs: params.timeoutMs ?? 300_000,
+      });
+
+      if (res.code !== 0) {
+         return { ok: false, error: `${pm} install failed: ${res.stderr || res.stdout}` };
+      }
+
+      return {
+        ok: true,
+        pluginId: params.spec,
+        targetDir: path.join(CONFIG_DIR, "node_modules", params.spec),
+        extensions: [],
+      };
+  }
+
   const logger = params.logger ?? defaultLogger;
   const timeoutMs = params.timeoutMs ?? 120_000;
   const mode = params.mode ?? "install";
